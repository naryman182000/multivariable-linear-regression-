# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ZynIKb0TgpyoOO-HDgqApicESMz7LLP
"""

import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import numpy as np

table=pd.read_csv("car_data.csv")

table.duplicated().sum()

table.describe()

table.corr()

plt.scatter(table["compressionratio"],table["price"])
plt.show()

plt.scatter(table["boreratio"],table["price"])
plt.show()

plt.scatter(table["carheight"],table["price"])
plt.show()

plt.scatter(table["symboling"],table["price"])
plt.show()

plt.scatter(table["carheight"],table["price"])
plt.show()

plt.scatter(table["enginesize"],table["price"])
plt.show()

plt.scatter(table["horsepower"],table["price"])
plt.show()

plt.scatter(table["highwaympg"],table["price"])
plt.show()

plt.scatter(table["citympg"],table["price"])
plt.show()

plt.scatter(table["carwidth"],table["price"])
plt.show()

plt.scatter(table["carlength"],table["price"])
plt.show()

plt.scatter(table["wheelbase"],table["price"])
plt.show()

plt.scatter(table["curbweight"],table["price"])
plt.show()

def normalize_features(x):
    new_feature=[]
    for i in range(len(x)) :
        z=((x[i]- x.min())/(x.max()-x.min()))
        new_feature.append(z)
    return new_feature

new_horsepower=normalize_features(table["horsepower"])
new_enginesize=normalize_features(table["enginesize"])
new_curbweight=normalize_features(table["curbweight"])
new_carwidth=normalize_features(table["carwidth"])
table['new_horsepower']=new_horsepower
table['new_enginesize']=new_enginesize
table['new_curbweight']=new_curbweight
table['new_carwidth']=new_carwidth

x_train, x_test, y_train, y_test = train_test_split(table[['new_horsepower', 'new_enginesize','new_curbweight','new_carwidth']], table[['price']], test_size=0.2,shuffle=True)
print(x_train.shape, y_train.shape)
print(x_test.shape, y_test.shape)

new_x=x_train

x_train.insert(4,'ones',1)

x_train.head()

x=np.array(x_train)
y=np.array(y_train).flatten()

theta=np.array([0,0,0,0,0])

m=len(y)

def cost_fun(x,y,theta):
  j=np.sum((x.dot(theta)-y)**2)/2/m
  return j

cost1=cost_fun(x,y,theta)
print(cost1)

iterations=1000
alpha=0.0000001

def gradiandesent(x,y,theta,alpha,iterations):
  cost_history=[0]*iterations
  for interation in range(iterations):
    hyposisis=x.dot(theta)
    loss=hyposisis-y
    gradian=x.T.dot(loss)/m
    theta=theta-(alpha *gradian )
    cost=cost_fun(x,y,theta)
    cost_history[interation]=cost
  return theta,cost_history

(t,c)=gradiandesent(x,y,theta,alpha,iterations)
print(t)

plt.plot(c)

zz=new_x.drop(columns='ones')

y_predicted=np.array(zz.dot(t[1:])+t[0])

y_predicted

m=y-y_predicted

plt.plot(m)

MSE = np.square(m).mean()

MSE